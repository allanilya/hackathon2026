---
phase: 03-feature-showcase
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - components/sections/FeatureShowcase.tsx
  - app/page.tsx
autonomous: true

must_haves:
  truths:
    - "Viewport locks on feature section while user scrolls through 4 feature slides"
    - "Feature slides transition smoothly driven by scroll progress (GSAP ScrollTrigger scrub)"
    - "Pinned section releases after final feature, allowing scroll to continue"
    - "Reduced motion users see all features stacked vertically without pinning"
  artifacts:
    - path: "components/sections/FeatureShowcase.tsx"
      provides: "Pinned scroll section with scrub-driven horizontal slide animation"
      exports: ["default"]
      min_lines: 60
    - path: "app/page.tsx"
      provides: "Homepage with FeatureShowcase replacing static cards"
      contains: "FeatureShowcase"
  key_links:
    - from: "components/sections/FeatureShowcase.tsx"
      to: "components/ui/FeatureSlide.tsx"
      via: "import and render FeatureSlide for each feature"
      pattern: "import.*FeatureSlide"
    - from: "components/sections/FeatureShowcase.tsx"
      to: "components/sections/featureData.ts"
      via: "import features array and Feature type"
      pattern: "import.*features.*featureData"
    - from: "components/sections/FeatureShowcase.tsx"
      to: "GSAP ScrollTrigger"
      via: "useGSAP hook with pin + scrub timeline"
      pattern: "pin:\\s*true.*scrub:\\s*0\\.5"
    - from: "app/page.tsx"
      to: "components/sections/FeatureShowcase.tsx"
      via: "import and render in features section position"
      pattern: "import FeatureShowcase"
---

<objective>
Build the FeatureShowcase section component with GSAP ScrollTrigger pinned scroll animation and integrate it into the homepage, replacing the static features placeholder.

Purpose: This is the core animation work for Phase 3 -- creating the premium scroll-linked experience where the viewport pins on the features section and slides swap horizontally as the user scrolls, driven by ScrollTrigger's scrub property.
Output: A fully animated pinned feature showcase on the homepage.
</objective>

<execution_context>
@C:\Users\antoi\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\antoi\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-feature-showcase/03-RESEARCH.md
@.planning/phases/03-feature-showcase/03-01-SUMMARY.md
@components/sections/Hero.tsx
@components/providers/SmoothScrollProvider.tsx
@app/page.tsx
@app/globals.css
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create FeatureShowcase with pinned scroll animation</name>
  <files>components/sections/FeatureShowcase.tsx</files>
  <action>
Create `components/sections/FeatureShowcase.tsx` as a client component ("use client").

Follow the EXACT pattern from 03-RESEARCH.md Pattern 1 (Pinned Container with Horizontal Slide Animation). Reference Hero.tsx for the established useGSAP + matchMedia pattern in this project.

**Imports:**
- `useRef` from react
- `useGSAP` from @gsap/react
- `gsap` from gsap
- `ScrollTrigger` from gsap/ScrollTrigger
- `FeatureSlide` from @/components/ui/FeatureSlide
- `features` from @/components/sections/featureData

Register plugin: `gsap.registerPlugin(ScrollTrigger)`

**Refs:**
- `containerRef` -- the outer section element (pin target)
- `slidesRef` -- the inner flex container holding all slides (animation target)

**Animation (inside useGSAP with scope: containerRef):**

Use `gsap.matchMedia()`:

For `(prefers-reduced-motion: no-preference)`:
1. Get slide count from `features.length`
2. Create a GSAP timeline with ScrollTrigger config:
   - `trigger`: containerRef.current
   - `pin`: true (locks viewport on this section)
   - `scrub`: 0.5 (smooth scroll-linked animation with 0.5s catch-up)
   - `start`: 'top top' (pin when section hits viewport top)
   - `end`: function returning `+=${features.length * 100}vh` (dynamic, responsive)
   - `invalidateOnRefresh`: true (recalculate on resize)
3. Loop through features starting at index 1 (skip first, already visible):
   - `tl.to(slidesRef.current, { xPercent: -100 * index, ease: 'none', duration: 1 })`
   - MUST use ease: 'none' for scrubbed animations
   - MUST use xPercent (not x pixels) for responsive behavior

For `(prefers-reduced-motion: reduce)`:
- `gsap.set(slidesRef.current, { clearProps: 'all' })`
- `gsap.set('.feature-slide', { clearProps: 'all' })`
- No pinning, no horizontal animation -- slides display stacked vertically via CSS

Cleanup: `return () => mm.revert()`

**JSX structure:**
```
<section ref={containerRef} id="features" className="h-screen overflow-hidden bg-stone-950">
  <div ref={slidesRef} className="flex h-full will-change-transform motion-reduce:flex-col motion-reduce:h-auto motion-reduce:overflow-y-auto">
    {features.map((feature) => (
      <FeatureSlide
        key={feature.id}
        icon={
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="1.5" strokeLinecap="round" strokeLinejoin="round" className="w-full h-full">
            {feature.iconPaths.map((d, i) => (
              <path key={i} d={d} />
            ))}
          </svg>
        }
        title={feature.title}
        description={feature.description}
      />
    ))}
  </div>
</section>
```

Key details:
- `will-change-transform` on slides container for GPU acceleration
- `overflow-hidden` on section prevents horizontal scrollbar from translated slides
- SVG icons rendered inline from iconPaths data, using currentColor to inherit text-burnt-orange from FeatureSlide
- `motion-reduce:flex-col motion-reduce:h-auto motion-reduce:overflow-y-auto` makes slides stack vertically for reduced motion
- Export as default: `export default function FeatureShowcase()`

CRITICAL anti-patterns to AVOID (from research):
- Do NOT animate containerRef (the pinned element) -- only animate slidesRef (its child)
- Do NOT use ease other than 'none' in scrubbed tweens
- Do NOT hard-code end value in pixels -- use function-based vh calculation
- Do NOT forget cleanup -- return () => mm.revert()
  </action>
  <verify>
Run `npx tsc --noEmit` to confirm no type errors. Verify the file uses "use client", imports from FeatureSlide and featureData, has useGSAP with matchMedia, pin: true, scrub: 0.5, and cleanup return.
  </verify>
  <done>
FeatureShowcase.tsx is a client component with: containerRef pinned via ScrollTrigger, slidesRef animated horizontally with xPercent, scrub: 0.5 for smooth scroll-linked control, dynamic end calculation, reduced motion fallback, and proper cleanup via mm.revert().
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate FeatureShowcase into homepage</name>
  <files>app/page.tsx</files>
  <action>
Update `app/page.tsx` to replace the static features section with the new FeatureShowcase component.

Changes:
1. Add import: `import FeatureShowcase from '@/components/sections/FeatureShowcase'`
2. Remove the Card import if it's only used in the features section (check -- it's also used in skills and use-cases sections, so KEEP the import)
3. Replace the entire `{/* Features Section */}` block (the `<section id="features" ...>` with the static card grid inside) with just: `<FeatureShowcase />`
4. Keep ALL other sections (demo, skills, use-cases, cta) exactly as they are -- do not modify them

The FeatureShowcase component internally handles its own `id="features"` attribute, background color (bg-stone-950 -- note this changes from the placeholder's bg-stone-50 to dark theme for premium feel), and full-screen height.

IMPORTANT: The features section was `bg-stone-50` (light) but FeatureShowcase uses `bg-stone-950` (dark). This is intentional -- the pinned showcase looks premium on dark backgrounds with light text. The next section (demo) is `bg-stone-900` which flows well from `bg-stone-950`.
  </action>
  <verify>
Run `npm run build` to confirm the page builds successfully with the new component. Verify page.tsx imports FeatureShowcase and renders it in the correct position (after Hero, before demo section).
  </verify>
  <done>
page.tsx renders FeatureShowcase component in place of static features cards. Build passes. Component order is: Hero -> FeatureShowcase -> Demo -> Skills -> Use Cases -> CTA.
  </done>
</task>

</tasks>

<verification>
- `npm run build` completes with no errors
- `npx tsc --noEmit` passes
- `app/page.tsx` imports and renders FeatureShowcase after Hero
- `components/sections/FeatureShowcase.tsx` has ScrollTrigger with pin: true and scrub: 0.5
- Feature slides use xPercent animation (not x pixels)
- Dynamic end calculation uses features.length * 100vh
- gsap.matchMedia() wraps animation with reduced motion fallback
- Cleanup returns mm.revert()
- No horizontal scrollbar visible (overflow-hidden on container)
</verification>

<success_criteria>
- Viewport pins on feature section when scrolled to top
- 4 feature slides transition horizontally via scroll-linked scrub
- Pin releases after final slide, continuing scroll to demo section
- Reduced motion disables pinning and shows slides stacked vertically
- Build passes with zero errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-feature-showcase/03-02-SUMMARY.md`
</output>
